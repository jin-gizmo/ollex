#!/usr/bin/env python3

"""
Slice and dice markdown for use with mkdocs.

WARNING: Only uses a single level of headers.


"""

from __future__ import annotations

import argparse
import os
import re
import sys
import unicodedata
from collections.abc import Iterator
from shutil import copyfile

import yaml

MD_HEADING_RE = re.compile(r'(?P<head>#+)\s+(?P<text>.*?)\s*#*$')

# This is a bit rough as regex is not the way to match paired parentheses
# Here we are looking for "](#something)"
MD_XREF_RE = re.compile(r']\(#(?P<xref>[^)]+)')

# This is a bit rough as regex is not the way to match paired parentheses
# Here we are looking for "[whatever](something)"
MD_LINK_RE = re.compile(r'\[(?P<text>[^]]+)]\((?P<href>[^)]+)\)')

HEADER_DEPTH = 1
MAX_HEADER_DEPTH = 10

__author__ = 'Murray Andrews'

PROG = os.path.basename(sys.argv[0])


# ------------------------------------------------------------------------------
def sanitise(value: str) -> str:
    """
    Turn an arbitrary string into something safe to use as a local filename.

    This code is based on slugify() from Django.

    :param value:       String to sanitise.
    :return:            Sanitised string

    """

    value = str(value)
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')
    value = re.sub(r'[^./=+\w\s-]', '', value).strip().lower()
    # ... value = re.sub(r'[/.]+', '.', value)
    value = re.sub(r'[.]+', '.', value)
    value = re.sub(r'/+', '', value)
    value = re.sub(r'[-\s]+', '-', value)
    return value.strip('.-')


# ------------------------------------------------------------------------------
class NumberedHeadingCounter:
    """
    Keep track of number headings.

    :param max_depth:
    """

    # --------------------------------------------------------------------------
    def __init__(self, max_depth: int = MAX_HEADER_DEPTH):
        """Create a counter."""

        if max_depth <= 0:
            raise ValueError(f'Bad max_depth: {max_depth}')

        self.max_depth = max_depth
        self.counter = [0] * max_depth

    # --------------------------------------------------------------------------
    def increment(self, level: int) -> None:
        """
        Increment the counter at the specified level.

        All lower level counters are reset.

        :param level:       The level number. Levels count from 1.
        """

        if level > self.max_depth:
            return

        for n in range(level, self.max_depth):
            self.counter[n] = 0
        self.counter[level - 1] += 1

    # --------------------------------------------------------------------------
    def __str__(self) -> str:
        """
        Return the counter as l1.l2...

        :return:
        """

        return '.'.join([f'{v}' for v in self.counter if v])

    # --------------------------------------------------------------------------
    def fmt(self, fmt: str = '{:02}') -> str:
        """
        Format the heading number as dot separated numbers.

        A specified format is applied to each compontent.

        :return:
        """

        return '.'.join([fmt.format(v) for v in self.counter if v])


# ------------------------------------------------------------------------------
def process_cli_args():
    """
    Process the command line arguments.

    :return:    The args namespace.
    """

    argp = argparse.ArgumentParser(
        prog=PROG, description='Slice and dice a markdown file for use with mkdocs.'
    )

    argp.add_argument(
        '-c',
        '--config',
        action='store',
        help='Mkdocs config file. If specified, and the file exists,'
        'the "nav" key will be updated.',
    )

    argp.add_argument(
        '-d',
        '--dir',
        action='store',
        default='.',
        help='Mkdocs document directory. Default is current directory.',
    )

    argp.add_argument('md_file', metavar='source.md', action='store', help='Markdown source.')

    return argp.parse_args()


# ------------------------------------------------------------------------------
def md_get_xrefs(line: str) -> list[str]:
    """
    Scan a line of markdown for anchor cross references.

    :param line:        Markdown line.
    :return:            A list of the bit after the # in the reference.
    """

    return MD_XREF_RE.findall(line)


# ------------------------------------------------------------------------------
def md_header_to_xref(hdr_txt: str) -> str:
    """
    Convert markdown header text to valid xref by stripping junk out.

    :param hdr_txt:     Header text.
    :return:            A valid xref string that can go in [..](#xref)
    """

    # Delete any xrefs embedded in the header then clean the result
    return sanitise(MD_LINK_RE.sub(r'\g<text>', hdr_txt))


# ------------------------------------------------------------------------------
def md_scan_headers(md_file: str) -> Iterator[tuple[bool, int, str, str, str]]:
    """
    Scan a markdown file and return individual lines, indicating if they are a header.

    :param md_file:     The source markdown file.
    :return:            An iterator that yields tuples:
                            (literal, header-level, heading-num, header-text, line)

                        The literal is a boolean indicating if the line is inside
                        a literal block.
                        If the line is not a header then first 3 items are None.
    """

    heading_ctr = NumberedHeadingCounter()
    literal_text = False

    with open(md_file) as fp:
        for line in fp:  # type: str
            line = line.rstrip('\n')
            level = None
            heading = None
            heading_num = None

            if line.startswith('```'):
                # Headers don't sit in literal blocks
                literal_text = not literal_text
            elif not literal_text:
                m = MD_HEADING_RE.match(line)
                if m:
                    # Found a header
                    level = len(m.group('head'))
                    heading = m.group('text')
                    heading_ctr.increment(level)
                    heading_num = heading_ctr.fmt()

            yield literal_text, level, heading_num, heading, line


# ------------------------------------------------------------------------------
def md_replace_xrefs(line: str, current_file: str, xref_map: dict[str, str]) -> str:
    """
    Replace cross references in a line of markdown.

    This is done by passing it through the xref map which indicates the file in
    which the xrefs have moved. References local to the current file are left
    alone.

    So if the input line is:
        Here is a xref [xref](#somewhere)
    and the map has:
        somewhere --> file.md
    the new line is:
        Here is a xref [xref](#file.md/somewhere)

    unless the current file is already file.md

    This is very inefficient.

    :param line:            The input line.
    :param current_file:    Current file name.
    :param xref_map:
    :return:
    """

    xrefs = md_get_xrefs(line)

    for xref in xrefs:
        if xref not in xref_map:
            print(f'{current_file}: Unknown cross-reference "{xref}"', file=sys.stderr)
            continue
        if xref_map[xref] != current_file:
            line = re.sub(f'\\(#{xref}\\)', f'({xref_map[xref]}#{xref})', line)

    return line


# ------------------------------------------------------------------------------
def main() -> int:
    """
    Do the business.

    :return: status
    """

    args = process_cli_args()

    if args.config and os.path.exists(args.config):
        # Backup the config file.
        copyfile(args.config, args.config + '~')
        with open(args.config) as fp:
            config = yaml.safe_load(fp)

    # ----------------------------------------
    # Pass 1 -- scan the file and build a map of all the headers for fixing
    #           and anchor references

    fname = None
    header_map = {}  # old-anchor-text: file
    for _, level, heading_num, heading, _ in md_scan_headers(args.md_file):
        if level:
            if level <= HEADER_DEPTH:
                # Switch to new file name
                fname = f'{heading_num}-{sanitise(heading)}.md'
            if fname:
                header_map[md_header_to_xref(heading)] = fname

    # ----------------------------------------
    # Pass 2 -- split the file and fix links. Skips stuff before first header.

    out_fp = None
    nav = []

    for literal, level, heading_num, heading, line in md_scan_headers(args.md_file):
        if level and level <= HEADER_DEPTH:
            # Start a new output file
            if out_fp:
                out_fp.close()
            fname = f'{heading_num}-{sanitise(heading)}.md'
            out_fp = open(os.path.join(args.dir, fname), 'w')  # noqa SIM115
            # TODO: This currently works at l1 only
            nav.append({heading: fname})

        if out_fp:
            print(md_replace_xrefs(line, fname, header_map) if not literal else line, file=out_fp)

    if out_fp:
        out_fp.close()

    # ----------------------------------------
    # Update the nav key in the config.
    if args.config:
        config['nav'] = nav

        with open(args.config, 'w') as fp:
            yaml.safe_dump(config, fp, default_flow_style=False, indent=2)

    return 0


if __name__ == '__main__':
    exit(main())
